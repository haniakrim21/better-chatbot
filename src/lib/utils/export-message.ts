/**
 * Utility for exporting chat messages in various formats.
 * Professional Edition v10: Ultra-Reliable Modern Report Engine.
 */
import jsPDF from "jspdf";
import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  ImageRun,
  AlignmentType,
} from "docx";
import { saveAs } from "file-saver";
import { toPng } from "html-to-image";

/**
 * Ultra-Reliable PDF: Renders a modern report in the "Visible Safety Zone".
 */
export const exportMessageAsPDFFromElement = async (
  elementId: string,
  filename: string = "message.pdf",
) => {
  const original = document.getElementById(elementId);
  if (!original) return;

  // 1. Create a "Report Stage" (Inside the visible screen to force rendering)
  const stageId = `pdf-stage-${Date.now()}`;
  const stage = document.createElement("div");
  stage.id = stageId;

  Object.assign(stage.style, {
    position: "fixed",
    top: "0",
    left: "0",
    width: "850px",
    backgroundColor: "#ffffff",
    color: "#000000",
    zIndex: "999999", // Highest priority
    opacity: "0.01", // Invisible but explicitly rendered
    pointerEvents: "none",
    padding: "50px",
    boxSizing: "border-box",
    fontFamily: "'Inter', sans-serif",
  });

  // 2. Build Modern Template Structure
  stage.innerHTML = `
    <div class="report-header" style="display: flex; justify-content: space-between; align-items: flex-end; border-bottom: 2px solid #0f172a; padding-bottom: 10px; margin-bottom: 30px;">
      <div>
        <h1 style="margin: 0; font-size: 22px; font-weight: 800; color: #0f172a;">DIGITAL INTELLIGENCE REPORT</h1>
        <p style="margin: 4px 0 0; font-size: 10px; color: #64748b; text-transform: uppercase; letter-spacing: 0.1em;">Generated by Better Chatbot Platform</p>
      </div>
      <div style="text-align: right;">
        <p style="margin: 0; font-size: 11px; font-weight: 600; color: #0f172a;">DATE: ${new Date().toLocaleDateString("en-US", { year: "numeric", month: "short", day: "numeric" })}</p>
      </div>
    </div>
    <div id="${stageId}-content"></div>
    <div style="margin-top: 30px; border-top: 1px solid #e2e8f0; padding-top: 10px; text-align: center;">
      <p style="font-size: 9px; color: #94a3b8;">CONFIDENTIAL ANALYSIS â€¢ PAGE 1</p>
    </div>
  `;

  const contentArea = stage.querySelector(`#${stageId}-content`) as HTMLElement;
  const clone = original.cloneNode(true) as HTMLElement;

  // Clean Clone
  clone
    .querySelectorAll('button, .actions, .avatar, [role="button"]')
    .forEach((el) => el.remove());

  // Style Normalization for Modern Look
  clone.querySelectorAll("*").forEach((el) => {
    const e = el as HTMLElement;
    e.style.color = "#000000";
    e.style.background = "transparent";
    if (e.tagName === "H1" || e.tagName === "H2" || e.tagName === "H3") {
      e.style.color = "#0f172a";
      e.style.fontWeight = "700";
    }
    if (
      e.classList.contains("recharts-wrapper") ||
      e.classList.contains("chart-container")
    ) {
      e.style.background = "#f8fafc";
      e.style.border = "1px solid #e2e8f0";
      e.style.borderRadius = "8px";
      e.style.padding = "15px";
      e.style.margin = "20px 0";
    }
  });

  contentArea.appendChild(clone);
  document.body.appendChild(stage);

  try {
    // 3. WAIT & VERIFY (Preventing Empty Capture)
    await new Promise((r) => setTimeout(r, 800)); // Longer wait for Recharts

    const dataUrl = await toPng(stage, {
      pixelRatio: 1.5,
      backgroundColor: "#ffffff",
      cacheBust: true,
      style: { opacity: "1" }, // Force full opacity for the capture
    });

    if (!dataUrl || dataUrl.length < 5000) {
      throw new Error("Capture returned blank/empty image");
    }

    // 4. CLEANUP
    document.body.removeChild(stage);

    // 5. PDF GENERATION (Standardized A4)
    const pdf = new jsPDF("p", "mm", "a4");
    const pageWidth = 210;
    const pageHeight = 297;
    const margin = 10;
    const innerWidth = pageWidth - margin * 2;
    const innerHeight = pageHeight - margin * 2;

    const img = new Image();
    await new Promise((resolve) => {
      img.onload = resolve;
      img.src = dataUrl;
    });

    const ratio = innerWidth / img.width;
    const pdfImgHeight = img.height * ratio;

    let heightLeft = pdfImgHeight;
    let pageNum = 0;

    while (heightLeft > 0) {
      if (pageNum > 0) pdf.addPage();

      pdf.addImage(
        dataUrl,
        "PNG",
        margin,
        margin - pageNum * innerHeight,
        innerWidth,
        pdfImgHeight,
        undefined,
        "FAST",
      );

      heightLeft -= innerHeight;
      pageNum++;
    }

    pdf.save(filename);
  } catch (error) {
    if (document.getElementById(stageId)) document.body.removeChild(stage);
    console.error("Critical Export Failure:", error);
    throw error;
  }
};

/**
 * Rich DOCX Generator with Image Embedding.
 */
export const exportMessageAsDOCX = async (
  elementId: string,
  filename: string = "message.docx",
) => {
  const element = document.getElementById(elementId);
  if (!element) return;

  const children = Array.from(element.children) as HTMLElement[];
  const docSections: any[] = [];

  for (const child of children) {
    const isVisual =
      child.querySelector(".recharts-wrapper") ||
      child.classList.contains("chart-container");

    if (isVisual) {
      try {
        const dataUrl = await toPng(child, {
          backgroundColor: "#ffffff",
          pixelRatio: 2,
        });
        const response = await fetch(dataUrl);
        const imageBuffer = await response.arrayBuffer();

        docSections.push(
          new Paragraph({
            children: [
              new ImageRun({
                data: imageBuffer,
                type: "png",
                transformation: { width: 550, height: 300 },
              }),
            ],
            alignment: AlignmentType.CENTER,
            spacing: { before: 200, after: 200 },
          }),
        );
      } catch (e) {
        console.error("DOCX Image Fail", e);
      }
    } else {
      const text = child.innerText || "";
      text.split("\n").forEach((line) => {
        const trimmed = line.trim();
        if (!trimmed) return;
        if (trimmed.startsWith("#")) {
          docSections.push(
            new Paragraph({
              text: trimmed.replace(/#+ /, ""),
              heading: HeadingLevel.HEADING_1,
              spacing: { before: 240, after: 120 },
            }),
          );
        } else {
          docSections.push(
            new Paragraph({
              children: [new TextRun(trimmed)],
              spacing: { after: 120 },
            }),
          );
        }
      });
    }
  }

  const doc = new Document({ sections: [{ children: docSections }] });
  const blob = await Packer.toBlob(doc);
  saveAs(blob, filename);
};
